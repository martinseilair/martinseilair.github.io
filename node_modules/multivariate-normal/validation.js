"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateCovAndGetSVD = exports.validateMean = undefined;

var _freeze = require("babel-runtime/core-js/object/freeze");

var _freeze2 = _interopRequireDefault(_freeze);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _numeric = require("numeric");

var _numeric2 = _interopRequireDefault(_numeric);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// freezes nested arrays
var deepFreeze = function deepFreeze(ary) {
    if (_lodash2.default.isArray(ary)) {
        ary.forEach(deepFreeze);
        (0, _freeze2.default)(ary);
    }
};

// validates a mean vector that's supposed to be of length n
//
// on success, freezes mean and returns it
var validateMean = function validateMean(mean, n) {
    // must be an array
    if (!_lodash2.default.isArray(mean)) {
        throw new Error("Mean must be an array");
    }

    // must be an array of numbers
    if (!_lodash2.default.every(mean, _lodash2.default.isNumber)) {
        throw new Error("Mean must be an array of numbers");
    }

    // must have the correct length
    if (mean.length !== n) {
        throw new Error("Expected mean to have length " + n + ", but had length " + mean.length);
    }

    (0, _freeze2.default)(mean);

    return mean;
};

// validates a covariance matrix that's supposed to be NxN. If successful,
// computes the SVD, freezes cov, and returns {cov, svd: { u, s, v }}
var validateCovAndGetSVD = function validateCovAndGetSVD(cov, n) {
    // must be an array
    if (!_lodash2.default.isArray(cov)) {
        throw new Error("Covariance must be an array");
    }

    // must have n elements
    if (cov.length !== n) {
        throw new Error("Covariance matrix had " + cov.length + " rows, but it should be a " + n + "x" + n + " square matrix");
    }

    // validate each row
    cov.forEach(function (row, idx) {
        // must be an array
        if (!_lodash2.default.isArray(row)) {
            throw new Error("Row " + idx + " of covariance matrix was not an array");
        }

        // must have n elements
        if (row.length !== n) {
            throw new Error("Row " + idx + " of covariance matrix had length " + row.length + ", but it should have length " + n);
        }

        // each element must be a number
        if (!_lodash2.default.every(row, _lodash2.default.isNumber)) {
            throw new Error("Row " + idx + " of covariance matrix contained a non-numeric value");
        }
    });

    // matrix must be positive semidefinite
    var eigenvalues = _numeric2.default.eig(cov).lambda.x;
    if (_lodash2.default.some(eigenvalues, function (v) {
        return v < 0;
    })) {
        throw new Error("Covariance isn't positive semidefinite");
    }

    // matrix must be symmetric
    if (!_numeric2.default.same(_numeric2.default.transpose(cov), cov)) {
        throw new Error("Covariance isn't symmetric");
    }

    // do decomposition
    // We use the SVD algorithm from Numeric.js because it's efficient and
    // reliable. Sylvester includes an SVD algorithm that doesn't hand some
    // edge cases and is also extremely slow (takes ~500ms to compute and SVD
    // for a 15x15 matrix). Numeric can do a 250x250 matrix in ~500ms.
    //
    // There's also node-svd, which is a wrapper around a C implementation.
    // It's slightly faster than Numeric (it can do a 370x370 matrix in ~500ms),
    // but can't run the browser and doesn't handle some edge cases well.

    var _Numeric$svd = _numeric2.default.svd(cov);

    var u = _Numeric$svd.U;
    var s = _Numeric$svd.S;
    var v = _Numeric$svd.V;

    // deep freeze cov and svd

    deepFreeze(cov);
    deepFreeze(u);
    deepFreeze(s);
    deepFreeze(v);

    return {
        cov: cov,
        svd: { u: u, s: s, v: v }
    };
};

exports.validateMean = validateMean;
exports.validateCovAndGetSVD = validateCovAndGetSVD;