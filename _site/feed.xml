<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-14T23:20:13+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ikigai</title><subtitle>A dump for random thoughts and observations</subtitle><entry><title type="html">Derivation of the Kalman filter</title><link href="http://localhost:4000/jekyll/update/2018/10/10/kalman_filter.html" rel="alternate" type="text/html" title="Derivation of the Kalman filter" /><published>2018-10-10T19:35:07+09:00</published><updated>2018-10-10T19:35:07+09:00</updated><id>http://localhost:4000/jekyll/update/2018/10/10/kalman_filter</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/10/10/kalman_filter.html">&lt;p&gt;The concept and the equations of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kalman_filter&quot;&gt;Kalman filter&lt;/a&gt; can be quite confusing at the beginning. Often the assumptions are not stated clearly and the equations are just falling from the sky. This post is an attempt to derive the equations of the Kalman filter in a systematic and hopefully understandable way using &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayesian_inference&quot;&gt;Bayesian inference&lt;/a&gt;. It addresses everyone, who wants to get a deeper understanding of the Kalman filter and is equipped with basic knowledge of linear algebra and probability theory.
&lt;!--more--&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    function draw_ssm(svg){


      var radius = 30;
      var dist_x = 120;
      var dist_y = 120;
      var margin_x = 50;
      var margin_y = 50;
      var markersize = 10;

      var input_ns = [];
      var state_ns = [];
      var output_ns = [];
      var edges = [];
      var T = 5;

      for (var t = 0; t&lt;T;t++){


      	if (t&lt;T-1) input_ns.push({title: &quot;\\( u_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y , fill:&quot;#e3e5feff&quot;});
        state_ns.push({title: &quot;\\( x_&quot; + t +&quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y + dist_y, fill:&quot;#FFFFFF&quot;});
        output_ns.push({title: &quot;\\( y_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});


        edges.push({source: state_ns[t], target: output_ns[t], dash:&quot;&quot;})
        if (t&gt;0) {
        	edges.push({source: state_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        	edges.push({source: input_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        }
      }

  	nodes = input_ns.concat(state_ns).concat(output_ns);
    create_graph(d3.select(svg), nodes, edges, radius, markersize);
    }

    function draw_ssm_ind(svg){


      var radius = 30;
      var dist_x = 120;
      var dist_y = 120;
      var margin_x = 100;
      var margin_y = 50;
      var markersize = 10;

      var input_ns = [];
      var state_ns = [];
      var output_ns = [];
      var edges = [];
      var T = 4;

      for (var t = 0; t&lt;T;t++){


      	ind = &quot;t&quot;

      	if (t&lt;T-1) ind+=(t-T+1)


      	if (t&lt;T-1) input_ns.push({title: &quot;\\( u_{&quot; + ind + &quot;}\\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y , fill:&quot;#e3e5feff&quot;});

      	statefill = (t==T-1) ? &quot;#e3e5feff&quot; :statefill = &quot;#FFFFFF&quot;;
        state_ns.push({title: &quot;\\( x_{&quot; + ind + &quot;} \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y + dist_y, fill:statefill});
        output_ns.push({title: &quot;\\( y_{&quot; + ind + &quot;} \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});



        edges.push({source: state_ns[t], target: output_ns[t], dash:&quot;&quot;})
        if (t&gt;0) {
        	edges.push({source: state_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        	edges.push({source: input_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        }
      }


    bstate_h = {x: state_ns[0].x - radius*4, y: state_ns[0].y}
    binput_h = {x: state_ns[0].x - 2*Math.sqrt(2)*radius, y: state_ns[0].y- 2*Math.sqrt(2)*radius}

    edges.push({source: bstate_h, target: state_ns[0], dash:&quot;5,5&quot;})
    edges.push({source: binput_h, target: state_ns[0], dash:&quot;5,5&quot;})


  	nodes = input_ns.concat(state_ns).concat(output_ns);
    create_graph(d3.select(svg), nodes, edges, radius, markersize);
    }

    function draw_ssm_indi(svg){


      var radius = 30;
      var dist_x = 120;
      var dist_y = 120;
      var margin_x = 100;
      var margin_y = 50;
      var markersize = 10;

      var input_ns = [];
      var state_ns = [];
      var output_ns = [];
      var edges = [];
      var T = 5;

      for (var t = 0; t&lt;T;t++){


      	ind = &quot;t&quot;

      	if (t&lt;2) ind+=(t-2)
      	if (t&gt;2) ind+=&quot;+&quot;+(t-2)


      	input_ns.push({title: &quot;\\( u_{&quot; + ind + &quot;}\\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y , fill:&quot;#e3e5feff&quot;});

      	statefill = (t==2) ? &quot;#e3e5feff&quot; :statefill = &quot;#FFFFFF&quot;;
        state_ns.push({title: &quot;\\( x_{&quot; + ind + &quot;} \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y + dist_y, fill:statefill});
        output_ns.push({title: &quot;\\( y_{&quot; + ind + &quot;} \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});



        edges.push({source: state_ns[t], target: output_ns[t], dash:&quot;&quot;})
        if (t&gt;0) {
        	edges.push({source: state_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        	edges.push({source: input_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        }
      }

    estate_h = {x: state_ns[T-1].x + radius*4, y: state_ns[T-1].y}
    bstate_h = {x: state_ns[0].x - radius*4, y: state_ns[0].y}
    einput_h = {x: input_ns[T-1].x + 2*Math.sqrt(2)*radius, y: input_ns[T-1].y+ 2*Math.sqrt(2)*radius}
    binput_h = {x: state_ns[0].x - 2*Math.sqrt(2)*radius, y: state_ns[0].y- 2*Math.sqrt(2)*radius}


    edges.push({source: state_ns[T-1], target: estate_h, dash:&quot;5,5&quot;})
    edges.push({source: bstate_h, target: state_ns[0], dash:&quot;5,5&quot;})
    edges.push({source: input_ns[T-1], target: einput_h, dash:&quot;5,5&quot;})
    edges.push({source: binput_h, target: state_ns[0], dash:&quot;5,5&quot;})


  	nodes = input_ns.concat(state_ns).concat(output_ns);
    create_graph(d3.select(svg), nodes, edges, radius, markersize);
    }

	function draw_ssm_obs(svg){


      var radius = 30;
      var dist_x = 120;
      var dist_y = 120;
      var margin_x = 50;
      var margin_y = 50;
      var markersize = 10;

      var input_ns = [];
      var state_ns = [];
      var output_ns = [];
      var edges = [];
      var T = 5;

      for (var t = 0; t&lt;T;t++){


      	if (t&lt;T-1) input_ns.push({title: &quot;\\( u_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y , fill:&quot;#e3e5feff&quot;});
        state_ns.push({title: &quot;\\( x_&quot; + t +&quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y + dist_y, fill:&quot;#FFFFFF&quot;});

        if (t==0||t==4) output_ns.push({title: &quot;\\( y_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*t , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});
        if (t==2) {
        	output_ns.push({title: &quot;\\( z_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*(t+0.5) , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});
			output_ns.push({title: &quot;\\( y_&quot; + t + &quot; \\)&quot;, type: &quot;prob&quot;, x: margin_x + dist_x*(t-0.5) , y: margin_y+ 2*dist_y, fill:&quot;#e3e5feff&quot;});
        }
        



        if (t&gt;0) {
        	edges.push({source: state_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        	edges.push({source: input_ns[t-1], target: state_ns[t], dash:&quot;&quot;})
        }
      }

      edges.push({source: state_ns[0], target: output_ns[0], dash:&quot;&quot;})
      edges.push({source: state_ns[2], target: output_ns[1], dash:&quot;&quot;})
      edges.push({source: state_ns[2], target: output_ns[2], dash:&quot;&quot;})
      edges.push({source: state_ns[4], target: output_ns[3], dash:&quot;&quot;})

  	nodes = input_ns.concat(state_ns).concat(output_ns);
    create_graph(d3.select(svg), nodes, edges, radius, markersize);
    }
 &lt;/script&gt;

&lt;script src=&quot;//d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;First of all, let’s try to formulate the main idea of Kalman filtering in one sentence:&lt;/p&gt;

&lt;div style=&quot;width:100%;background-color:#fffbde;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;The &lt;strong&gt;Kalman filter&lt;/strong&gt; is used to &lt;strong&gt;infer&lt;/strong&gt; the current state of a &lt;strong&gt;linear Gaussian state space model&lt;/strong&gt; given all observations and inputs up to the current timestep and a Gaussian prior distribution of the initial state.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Indeed, the process of Kalman filtering is simply Bayesian inference in the domain of linear Gaussian state space models. The information encoded in our formulation is sufficient to uniquely define what the Kalman filter should output. But it doesn’t tell us anything about how to compute it. In this article, we will find an efficient recursive method that will lead us to the familiar equations.&lt;/p&gt;

&lt;p&gt;Let’s get started with the derivation by defining &lt;em&gt;linear Gaussian state space models&lt;/em&gt; and &lt;em&gt;Bayesian inference&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;linear-gaussian-state-space-models&quot;&gt;Linear Gaussian state space models&lt;/h2&gt;

&lt;p&gt;A linear Gaussian state space model is defined by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}x_{t+1} &amp;= A_tx_t + B_t u_t + w_t \\ 
y_t &amp;= C_tx_t + v_t \end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;with state \(x_t\), output \(y_t\), input \(u_t\), system matrix \(A_t\), input matrix \(B_t\), output matrix \(C_t\), Gaussian process noise \( w_t \sim \mathcal{N}(w_t|0, Q_t) \) and Gaussian observation noise \( v_t \sim \mathcal{N}(v_t|0, R_t) \).&lt;/p&gt;

&lt;p&gt;Alternatively, we can use the probability density functions&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}x_{t+1} &amp;\sim \mathcal{N}(x_{t+1}|A_tx_t + B_t u_t, Q_t)\\ 
 y_t &amp;\sim \mathcal{N}(y_t|C_tx_t, R_t)\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;to describe the system in a more compact fashion.&lt;/p&gt;

&lt;p&gt;Linear Gaussian state space models can also be described in the language of &lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_model&quot;&gt;probabilistic graphical models&lt;/a&gt; (or more precisely in the language of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayesian_network&quot;&gt;Bayesian networks&lt;/a&gt;). The figure below shows such a model up to time \(T = 4\).&lt;/p&gt;

&lt;svg style=&quot;display: block;margin: auto;text-align: center;&quot; onload=&quot;draw_ssm(this);&quot; width=&quot;600&quot; height=&quot;350&quot;&gt;&lt;/svg&gt;

&lt;p&gt;Every node represents a random variable and the edges are representing conditional dependencies between the respective nodes. Random variables, that are observed (or given) are shaded in light blue. In our case this is the output \(y_t\) and the input \(u_t\). The state \(x_t\) is not observed (or latent).&lt;/p&gt;

&lt;h2 id=&quot;bayesian-inference&quot;&gt;Bayesian inference&lt;/h2&gt;

&lt;p&gt;In simplest terms Bayesian inference tries to update a hypothesis/belief of something, that is not directly observable, in the face of new information by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayes%27_theorem&quot;&gt;Bayes’ rule&lt;/a&gt;. A bit more formal: The goal is to update the prior distribution \(p(x)\) given new data \(\mathcal{D}\) to obtain the posterior distribution \(p(x|\mathcal{D})\) with help of Bayes rule&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x|\mathcal{D}) = \frac{p(\mathcal{D}|x)p(x)}{p(\mathcal{D})}&lt;/script&gt;

&lt;p&gt;with likelihood \(p(\mathcal{D}|x)\) and evidence \(p(\mathcal{D})\).&lt;/p&gt;

&lt;p&gt;This idea is very general and can be applied to dynamical models quite easily. The most common inference tasks in dynamical models are filtering, smoothing and prediction. These methods differ only in the form of the posterior distribution.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Filtering&lt;/strong&gt;: What is my belief about the &lt;strong&gt;last state&lt;/strong&gt; \(x_t\) given all observations and inputs?&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;font-size:150%&quot;&gt; 	$$ p(x_t|y_0,...,y_t,u_0,...,u_{t-1})  $$ &lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Smoothing&lt;/strong&gt;: What is my belief about the &lt;strong&gt;all states&lt;/strong&gt; \(x_t, … ,x_0\) given all observations and inputs?&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;font-size:150%&quot;&gt; $$ p(x_t,...,x_0|y_0,...,y_t,u_0,...,u_{t-1}) $$ &lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Prediction&lt;/strong&gt;: What is my belief about the &lt;strong&gt;next state&lt;/strong&gt; \(x_{t+1}\) given all observations and inputs?&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;font-size:150%&quot;&gt; $$ p(x_{t+1}|y_0,...,y_t,u_0,...,u_{t-1}) $$ &lt;/div&gt;

&lt;p&gt;The name Kalman &lt;em&gt;filter&lt;/em&gt; reveals, that we will be interested in the filtering problem. Therefore, we want to infer the current state \(x_t\) based on all recent observations \(y_0,…,y_t\) and inputs \(y_0,…,u_{t-1}\).
Now that we have defined what we are looking for, let’s try to find a way to efficiently calculate it. We will start by finding a recursive method for &lt;em&gt;general&lt;/em&gt; dynamical models defined by the probabilistic graphical model above.&lt;/p&gt;

&lt;h2 id=&quot;bayes-filter-for-state-space-models&quot;&gt;Bayes filter for state space models&lt;/h2&gt;

&lt;p&gt;We have the task to calculate \( p(x_{t}|y_0,…,y_t,u_0,…,u_{t-1}) \). For this purpose only the structure of the graphical model will matter: it governs the conditional dependencies.
To unclutter the notation we will use \(\Box_{n:m}\) for \(\Box_n,…,\Box_m\).&lt;/p&gt;

&lt;p&gt;With help of &lt;strong&gt;Bayes’ rule&lt;/strong&gt; we can rewrite the formula as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t},u_{0:t-1}) = \frac{p(y_t|x_t,y_{0:t-1},u_{0:t-1})p(x_t|y_{0:t-1},u_{0:t-1})}{p(y_t|y_{0:t-1},u_{0:t-1})}.&lt;/script&gt;

&lt;div style=&quot;border-style: solid;border-color:gray;width:100%;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;If you are not very familiar with Bayes’ rule this can be quite confusing. There are much more moving parts than in the very simple definition. Nonetheless, there is an intuitive explanation.
It is Bayes’ rule applied in a world, where we already observed \(\mathcal{W}\) in the past (every term is conditioned on \(\mathcal{W}\)):&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x|\mathcal{D},\mathcal{W}) = \frac{p(\mathcal{D}|x,\mathcal{W})p(x|\mathcal{W})}{p(\mathcal{D}|\mathcal{W})}.&lt;/script&gt;

  &lt;p&gt;In our case \(x:=x_t \), \(\mathcal{D}:=y_t \) and \(\mathcal{W}:=(y_{0:t-1},u_{0:t-1}) \).&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;We note that \(y_t\) is independent of \(y_{0:t-1}\) and  \(u_{0:t-1}\) given \(x_t\). It follows&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t},u_{0:t-1}) = \frac{p(y_t|x_t)p(x_t|y_{0:t-1},u_{0:t-1})}{p(y_t|y_{0:t-1},u_{0:t-1})}.&lt;/script&gt;

&lt;div style=&quot;border-style: solid;border-color:gray;width:100%;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;This conditional independence property is not obvious as well. When it comes to conditional dependencies, it is always a good idea to look at the graphical model.&lt;/p&gt;

  &lt;svg style=&quot;display: block;margin: auto;text-align: center;&quot; onload=&quot;draw_ssm_ind(this);&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;&lt;/svg&gt;
  &lt;p&gt;In the figure above we notice that the node \(x_t\) is shaded (observed). This node blocks the way of \(y_{0:t-1}\) and  \(u_{0:t-1}\) to \(y_t\). We have proven the conditional independence &lt;em&gt;visually&lt;/em&gt;. You can learn more about conditional independence in probabilistic graphical models in &lt;a href=&quot;https://www.microsoft.com/en-us/research/people/cmbishop/#!prml-book&quot;&gt;Pattern Recognition and Machine Learning&lt;/a&gt; (Chapter 8.2).&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The denominator is simply the integral of the numerator&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(y_t|y_{0:t-1},u_{0:t-1}) = \int_{x_t} p(y_t|x_t)p(x_t|y_{0:t-1},u_{0:t-1}) dx_t .&lt;/script&gt;

&lt;p&gt;Great! Now we have the first step of our approach. But now we obtained the new expression \(p(x_t|y_{0:t-1},u_{0:t-1})\) that we have to calculate as well. Using marginalization we can express it as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t-1},u_{0:t-1}) = \int_{x_{t-1}} p(x_t,x_{t-1}|y_{0:t-1},u_{0:t-1}) dx_{t-1}.&lt;/script&gt;

&lt;p&gt;We can split the expression in the integral with product rule, which leads to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t-1},u_{0:t-1}) = \int_{x_{t-1}} p(x_t|x_{t-1},y_{0:t-1},u_{0:t-1})p(x_{t-1}|y_{0:t-1},u_{0:t-1}) dx_{t-1}.&lt;/script&gt;

&lt;p&gt;Note that \(x_t\) is independent of \(y_{0:t-1}\) and \(u_{0:t-2}\) given \(x_{t-1}\). Furthermore, \(x_{t-1}\) is independent of \(u_{t-1}\). We obtain&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t-1},u_{0:t-1}) = \int_{x_{t-1}} p(x_t|x_{t-1}, u_{t-1})p(x_{t-1}|y_{0:t-1},u_{0:t-2}) dx_{t-1}.&lt;/script&gt;

&lt;p&gt;We note that \(p(x_{t-1}|y_{0:t-1},u_{0:t-2})\) has the same form as our expression we started from only shifted by one time step. Our recursive formula is complete!&lt;/p&gt;

&lt;p&gt;Let’s summarize our results!&lt;/p&gt;

&lt;div style=&quot;width:100%;background-color:#fffbde;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;&lt;span style=&quot;font-family:'Arial Black';&quot;&gt;Bayes filter for state space models&lt;/span&gt;&lt;/p&gt;

  &lt;p&gt;The recursive formula for the Bayes filter in state space models consists of the &lt;strong&gt;prediction step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_{t+1}|y_{0:t},u_{0:t}) = \int_{x_{t}} p(x_{t+1}|x_{t}, u_{t})p(x_{t}|y_{0:t},u_{0:t-1}) dx_{t}&lt;/script&gt;

  &lt;p&gt;and the &lt;strong&gt;update step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;p(x_t|y_{0:t},u_{0:t-1}) = \frac{p(y_t|x_t)p(x_t|y_{0:t-1},u_{0:t-1})}{p(y_t|y_{0:t-1},u_{0:t-1})} .&lt;/script&gt;

  &lt;p&gt;The recursion is started with the prior distribution over the initial state \(p(x_0)\).&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;Up to this point, we assumed that we obtain exactly one observation at every timestep. This rather limiting assumption is violated in many real-life scenarios. Multiple or even no observations per timestep are possible. This behavior is exemplified in the probabilistic graphical model below.&lt;/p&gt;

&lt;svg style=&quot;display: block;margin: auto;text-align: center;&quot; onload=&quot;draw_ssm_obs(this);&quot; width=&quot;600&quot; height=&quot;350&quot;&gt;&lt;/svg&gt;

&lt;p&gt;Fortunately, handling these cases is very simple. For every observation we make, we calculate the update step with the newest estimate available. Furthermore, it is not necessary that the observations are coming from the same output function (illustrated by the outputs \(y_2\) and \(z_2\) at \(t=2\)). &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_integration&quot;&gt;Information integration/fusion&lt;/a&gt; is very natural in Bayesian inference.&lt;/p&gt;

&lt;p&gt;Nice! We just derived the equations of the Bayes filter for general state space models!
Now let’s translate this into the linear state space scenario.&lt;/p&gt;

&lt;h2 id=&quot;bayes-filter-in-linear-gaussian-state-space-models&quot;&gt;Bayes filter in linear Gaussian state space models&lt;/h2&gt;

&lt;p&gt;Let’s start by identifying the probability distributions we already know:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
p(x_{t+1}|x_{t}, u_{t})  &amp;= \mathcal{N}(x_{t+1}|A_tx_t + B_t u_t, Q_t) \\
p(y_t|x_t) &amp;=  \mathcal{N}(y_t|C_tx_t, R_t). 
 \end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Furthermore, we assume that the prior distribution of the initial state is Gaussian as well. All probability distributions in our model are Gaussian. Therefore, the distributions \(p(x_t|y_{0:t-1},u_{0:t-1})\) and \(p(x_t|y_{0:t},u_{0:t-1})\) will also be in form of Gaussian distributions, because our recursive formula is only using marginalization and Bayes’ rule, which are closed under Gaussian distributions. In the context of Kalman filtering, these are normally defined by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
p(x_t|y_{0:t},u_{0:t-1}) &amp;:= \mathcal{N}(x_{t}|\hat x_{t|t}, P_{t|t}) \\
p(x_t|y_{0:t-1},u_{0:t-1}) &amp;:= \mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1}) .
 \end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Please note, that these distributions are still implicitly dependent on the inputs and outputs. The mean and the covariance are a &lt;em&gt;sufficient statistic&lt;/em&gt; of the in- and outputs.&lt;/p&gt;

&lt;p&gt;The index \(\Box_{n|m}\) of the parameters indicates that the state at time \(n\) is estimated, based on the outputs upto time \(m\).
The expression \(\hat x_{t|t}\) is called the &lt;em&gt;updated&lt;/em&gt; state estimate and \( P_{t|t}\) the &lt;em&gt;updated&lt;/em&gt; error covariance. Moreover, \(\hat x_{t|t-1}\) is called the &lt;em&gt;predicted&lt;/em&gt; state estimate and \( P_{t|t-1}\) the &lt;em&gt;predicted&lt;/em&gt; error covariance.&lt;/p&gt;

&lt;p&gt;In summary, these are the equations for the Bayes filter in linear Gaussian state space models:&lt;/p&gt;
&lt;div style=&quot;width:100%;background-color:#fffbde;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;

  &lt;p&gt;&lt;strong&gt;Prediction step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t+1}|\hat x_{t+1|t}, P_{t+1|t})  = \int_{x_t}\mathcal{N}(x_{t+1}|A_tx_t + B_t u_t, Q_t)\mathcal{N}(x_t|\hat x_{t|t}, P_{t|t}) dx_t.&lt;/script&gt;

  &lt;p&gt;&lt;strong&gt;Update step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t}|\hat x_{t|{t}}, P_{t|t} ) = \frac{\mathcal{N}(y_{t}|C_tx_{t}, R_t )\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1})}{\int_{x_{t}}\mathcal{N}(y_{t}|C_tx_{t}, R_t )\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1}) dx_{t}}&lt;/script&gt;

&lt;/div&gt;

&lt;p&gt;Let’s try to simplify these equations!&lt;/p&gt;

&lt;h3 id=&quot;prediction-step&quot;&gt;Prediction step&lt;/h3&gt;

&lt;p&gt;We will start with the prediction step&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t+1}|\hat x_{t+1|t}, P_{t+1|t})  = \int_{x_t}\mathcal{N}(x_{t+1}|A_tx_t + B_t u_t, Q_t)\mathcal{N}(x_t|\hat x_{t|t}, P_{t|t}) dx_t.&lt;/script&gt;

&lt;p&gt;In order to find a closed form solution of this integral, we could simply plug in the corresponding expressions of the Gaussian distributions and solve the integral. Fortunately, Marc Toussaint already gathered the most important &lt;a href=&quot;https://ipvs.informatik.uni-stuttgart.de/mlr/marc/notes/gaussians.pdf&quot;&gt;Gaussian identities&lt;/a&gt;, which will lighten our workload a lot.  To find an expression for our prediction step we can simply use the &lt;em&gt;propagation&lt;/em&gt; formula (Formula 37, Toussaint)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{y}\mathcal{N}(x|a + Fy, A)\mathcal{N}(y|b,B) dx_t = \mathcal{N}(x|a + Fb, A + FBF^T ).&lt;/script&gt;

&lt;p&gt;By comparison with our expression, we see that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat x_{t+1|t} =  A_t \hat x_{t|t} + B_tu_t,&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_{t+1|t} = Q_t + A_t P_{t|t} A_t^T  .&lt;/script&gt;

&lt;h3 id=&quot;update-step&quot;&gt;Update step&lt;/h3&gt;

&lt;p&gt;We will start to simplify the update step&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t}|\hat x_{t|{t}}, P_{t|t} ) = \frac{\mathcal{N}(y_{t}|C_tx_{t}, R_t )\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1})}{\int_{x_{t}}\mathcal{N}(y_{t}|C_tx_{t}, R_t )\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1}) dx_{t}}&lt;/script&gt;

&lt;p&gt;by focussing on the numerator first. We notice that we can rewrite it as a joint distribution (Formula 39, Toussaint)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\mathcal{N}(x|a,A)\mathcal{N}(y|b + Fx,B) = \mathcal{N}\left(\begin{matrix}x \\y\end{matrix}\middle|\begin{matrix}a\\b + Fa \end{matrix},\begin{matrix}A &amp; A^TF^T\\FA &amp; B + FA^TF^T\end{matrix}\right) . %]]&gt;&lt;/script&gt;

&lt;p&gt;Then again, this joint distribution can be rewritten as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\mathcal{N}\left(\begin{matrix}x \\y\end{matrix}\middle|\begin{matrix}d\\e \end{matrix},\begin{matrix}D &amp; F\\E^T &amp; E\end{matrix}\right) = \mathcal{N}(y|e,E)\mathcal{N}(x|d + F^TE^{-1}(y-e),D - F^T E^{-1}F) . %]]&gt;&lt;/script&gt;

&lt;p&gt;We can combine the two previous equations to the following expression&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x|a,A)\mathcal{N}(y|b + Fx,B) = \mathcal{N}(y|b + Fa,B + FA^TF^T) \mathcal{N}(x|a + A^TF^T(B + FA^TF^T)^{-1}(y-b -Fa),A - A^TF^T (B + FA^TF^T)^{-1}FA) .&lt;/script&gt;

&lt;p&gt;By comparison with the numerator of our update step, we obtain&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1})\mathcal{N}(y_{t}|C_tx_{t}, R_t ) = \mathcal{N}(y_{t}|C_t\hat x_{t|t},R_t + C_tP_{t|t-1}C_t^T)  \mathcal{N}(x_{t}|\hat x_{t|t-1} + P_{t|t-1}C_t^T(R_t + C_tP_{t|t-1}C_t^T)^{-1}(y_{t}-C_t\hat x_{t}),  P_{t|t-1} - P_{t|t-1}C_t^T (R_t + C_tP_{t|t-1}C_t^T)^{-1}C_tP_{t|t-1}).&lt;/script&gt;

&lt;p&gt;At a first glance, this is not looking like a simplification at all. Conceptually, we only transformed&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{p(y|x)p(x)}{p(y)} \to \frac{p(y,x)}{p(y)} \to \frac{p(x|y)p(y)}{p(y)}.&lt;/script&gt;

&lt;p&gt;If we look closely at the final expression, we see that \(p(y)\) is canceling out. Therefore, the result is simply the remaining part&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x_{t}|\hat x_{t|{t}}, P_{t|t} ) = \mathcal{N}(x_{t}|\hat x_{t|t-1} + P_{t|t-1}C_t^T(R_t + C_tP_{t|t-1}C_t^T)^{-1}(y_{t}-C_t\hat x_{t}),P_{t|t-1} - P_{t|t-1}C_t^T (R_t + C_tP_{t|t-1}C_t^T)^{-1}C_tP_{t|t-1}).&lt;/script&gt;

&lt;p&gt;If our reasoning is correct the denominator should be equal to \(\mathcal{N}(y_{t}|C_t\hat x_{t|t},R_t + C_tP_{t|t-1}C_t^T)\), that was cancelled out. The denominator can be simplified with the &lt;em&gt;propagation&lt;/em&gt; formula (Formula 37, Toussaint)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{x_{t}}\mathcal{N}(y_{t}|C_tx_{t}, R_t )\mathcal{N}(x_{t}|\hat x_{t|t-1}, P_{t|t-1}) dx_{t} =  \mathcal{N}({y_{t}}|C_t\hat x_{t|t-1}, R_t + C_tP_{t|t-1}C_t^T ).&lt;/script&gt;

&lt;p&gt;Yay! We see, that the denominator is exactly the same as the canceled factor in the numerator.&lt;/p&gt;

&lt;p&gt;Let’s summarize our results:&lt;/p&gt;

&lt;div style=&quot;width:100%;background-color:#fffbde;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;&lt;span style=&quot;font-family:'Arial Black';&quot;&gt;Bayes filter in linear Gaussian state space models&lt;/span&gt;&lt;/p&gt;

  &lt;p&gt;The recursive formula for the Bayes filter in linear Gaussian state space models consists of the &lt;strong&gt;prediction step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}\hat x_{t+1|t} &amp;=  A_t \hat x_{t|t} + B_tu_t \\ 
P_{t+1|t} &amp;= Q_t + A_t P_{t|t} A_t^T  \end{align} %]]&gt;&lt;/script&gt;

  &lt;p&gt;and the &lt;strong&gt;update step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}\hat x_{t|t} &amp;= \hat x_{t|t-1} + P_{t|t-1}C_t^T(R_t + C_tP_{t|t-1}C_t^T)^{-1}(y_{t}-C_t\hat x_{t}) \\ 
P_{t|t} &amp;= P_{t|t-1} - P_{t|t-1}C_t^T (R_t + C_tP_{t|t-1}C_t^T)^{-1}C_tP_{t|t-1}.  \end{align} %]]&gt;&lt;/script&gt;

&lt;/div&gt;
&lt;p&gt;That’s it! We derived the equations of the Bayes filter in linear Gaussian state space models, which is nothing else but the good old Kalman filter.
In the next section, we will split up these equations to finally obtain the formulation normally used for the Kalman filter.&lt;/p&gt;

&lt;h2 id=&quot;kalman-filter&quot;&gt;Kalman filter&lt;/h2&gt;

&lt;p&gt;In order to obtain the familiar equations of the Kalman filter we have to define&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Innovation&lt;/strong&gt;&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;z_t = y_{t}-C_t\hat x_{t|t-1}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Innovation covariance&lt;/strong&gt;&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;S_t = R_t + C_tP_{t|t-1}C_t^T&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Optimal Kalman gain&lt;/strong&gt;&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;K_t = P_{t|t-1}C_t^TS_t^{-1}&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s plug these definitions into the equations of our update step&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat x_{t|t} = \hat x_{t|t-1} + \underbrace{P_{t|t-1}C_t^T(\underbrace{R_t + C_tP_{t|t-1}C_t^T}_{S_t})^{-1}}_{K_t}(\underbrace{y_{t}-C_t\hat x_{t}}_{z_t})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_{t|t} = P_{t|t-1} - \underbrace{P_{t|t-1}C_t^T(\underbrace{R_t + C_tP_{t|t-1}C_t^T}_{S_t})^{-1}}_{K_t}P_{t|t-1} .&lt;/script&gt;

&lt;p&gt;This leads us to the final equations of the Kalman filter.&lt;/p&gt;

&lt;div style=&quot;width:100%;background-color:#fffbde;padding-top: 15px;padding-bottom: 1px;padding-left: 15px;padding-right: 15px;margin-bottom:14px&quot;&gt;
  &lt;p&gt;&lt;span style=&quot;font-family:'Arial Black';&quot;&gt;Equations of the Kalman filter&lt;/span&gt;&lt;/p&gt;

  &lt;p&gt;The recursive formula for the Kalman filter consists of the &lt;strong&gt;prediction step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}\hat x_{t+1|t} &amp;=  A_t \hat x_{t|t} + B_tu_t \\ 
P_{t+1|t} &amp;= Q_t + A_t P_{t|t} A_t^T \end{align} %]]&gt;&lt;/script&gt;

  &lt;p&gt;and the &lt;strong&gt;update step&lt;/strong&gt;&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
z_t &amp;= y_{t}-C_t\hat x_{t|t-1}\\
S_t &amp;= R_t + C_tP_{t|t-1}C_t^T\\
K_t &amp;= P_{t|t-1}C_t^TS_t^{-1} \\
\hat x_{t|t} &amp;= \hat x_{t|t-1} + K_t z_t\\
P_{t|t} &amp;= (I - K_tC_t)P_{t|t-1}.
\end{align} %]]&gt;&lt;/script&gt;

&lt;/div&gt;

&lt;h2 id=&quot;interpreation-of-z_t-and-s_t&quot;&gt;Interpreation of \(z_t\) and \(S_t\)&lt;/h2&gt;
&lt;p&gt;What is the meaning of \(z_t\) and \(S_t\)? The denominator of the update step is&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(y_{t}|C_t\hat x_{t|t-1},R_t + C_tP_{t|t-1}^TC_t^T)&lt;/script&gt;

&lt;p&gt;and can be transformed by (Formula 34, Toussaint)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(x|a,A) = \mathcal{N}(x+f|a+f,A)&lt;/script&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{N}(y_{t} - C_t\hat x_{t|t-1}|0,R_t + C_tP_{t|t-1}^TC_t^T) = \mathcal{N}(z_t|0,S_t).&lt;/script&gt;

&lt;p&gt;Therefore, \(z_t\) gives you the derivation of the expected output and the observed output.
The random variable \(z_t\) has a Gaussian distribution with zero mean and variance \(S_t\).&lt;/p&gt;

&lt;script src=&quot;http://localhost:4000/assets/js/d3_graphical_model.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  &quot;HTML-CSS&quot;: { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:4000/assets/js/svg_mathjax.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_SVG&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;new Svg_MathJax().install();&lt;/script&gt;</content><author><name></name></author><summary type="html">The concept and the equations of the Kalman filter can be quite confusing at the beginning. Often the assumptions are not stated clearly and the equations are just falling from the sky. This post is an attempt to derive the equations of the Kalman filter in a systematic and hopefully understandable way using Bayesian inference. It addresses everyone, who wants to get a deeper understanding of the Kalman filter and is equipped with basic knowledge of linear algebra and probability theory.</summary></entry></feed>